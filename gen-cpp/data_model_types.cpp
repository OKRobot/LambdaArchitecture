/**
 * Autogenerated by Thrift Compiler (0.11.0)
 *
 * DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
 *  @generated
 */
#include "data_model_types.h"

#include <algorithm>
#include <ostream>

#include <thrift/TToString.h>



int _kGenderTypeValues[] = {
  GenderType::MALE,
  GenderType::FEMALE
};
const char* _kGenderTypeNames[] = {
  "MALE",
  "FEMALE"
};
const std::map<int, const char*> _GenderType_VALUES_TO_NAMES(::apache::thrift::TEnumIterator(2, _kGenderTypeValues, _kGenderTypeNames), ::apache::thrift::TEnumIterator(-1, NULL, NULL));

std::ostream& operator<<(std::ostream& out, const GenderType::type& val) {
  std::map<int, const char*>::const_iterator it = _GenderType_VALUES_TO_NAMES.find(val);
  if (it != _GenderType_VALUES_TO_NAMES.end()) {
    out << it->second;
  } else {
    out << static_cast<int>(val);
  }
  return out;
}


PersonID::~PersonID() throw() {
}


void PersonID::__set_cookie(const std::string& val) {
  this->cookie = val;
__isset.cookie = true;
}

void PersonID::__set_user_id(const int64_t val) {
  this->user_id = val;
__isset.user_id = true;
}
std::ostream& operator<<(std::ostream& out, const PersonID& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PersonID::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->cookie);
          this->__isset.cookie = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->user_id);
          this->__isset.user_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PersonID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PersonID");

  if (this->__isset.cookie) {
    xfer += oprot->writeFieldBegin("cookie", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->cookie);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.user_id) {
    xfer += oprot->writeFieldBegin("user_id", ::apache::thrift::protocol::T_I64, 2);
    xfer += oprot->writeI64(this->user_id);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PersonID &a, PersonID &b) {
  using ::std::swap;
  swap(a.cookie, b.cookie);
  swap(a.user_id, b.user_id);
  swap(a.__isset, b.__isset);
}

PersonID::PersonID(const PersonID& other0) {
  cookie = other0.cookie;
  user_id = other0.user_id;
  __isset = other0.__isset;
}
PersonID& PersonID::operator=(const PersonID& other1) {
  cookie = other1.cookie;
  user_id = other1.user_id;
  __isset = other1.__isset;
  return *this;
}
void PersonID::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PersonID(";
  out << "cookie="; (__isset.cookie ? (out << to_string(cookie)) : (out << "<null>"));
  out << ", " << "user_id="; (__isset.user_id ? (out << to_string(user_id)) : (out << "<null>"));
  out << ")";
}


PageID::~PageID() throw() {
}


void PageID::__set_url(const std::string& val) {
  this->url = val;
__isset.url = true;
}
std::ostream& operator<<(std::ostream& out, const PageID& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PageID::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->url);
          this->__isset.url = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PageID::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PageID");

  if (this->__isset.url) {
    xfer += oprot->writeFieldBegin("url", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->url);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PageID &a, PageID &b) {
  using ::std::swap;
  swap(a.url, b.url);
  swap(a.__isset, b.__isset);
}

PageID::PageID(const PageID& other2) {
  url = other2.url;
  __isset = other2.__isset;
}
PageID& PageID::operator=(const PageID& other3) {
  url = other3.url;
  __isset = other3.__isset;
  return *this;
}
void PageID::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageID(";
  out << "url="; (__isset.url ? (out << to_string(url)) : (out << "<null>"));
  out << ")";
}


EquivEdge::~EquivEdge() throw() {
}


void EquivEdge::__set_id1(const PersonID& val) {
  this->id1 = val;
}

void EquivEdge::__set_id2(const PersonID& val) {
  this->id2 = val;
}
std::ostream& operator<<(std::ostream& out, const EquivEdge& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t EquivEdge::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id1 = false;
  bool isset_id2 = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id1.read(iprot);
          isset_id1 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id2.read(iprot);
          isset_id2 = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id1)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_id2)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t EquivEdge::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("EquivEdge");

  xfer += oprot->writeFieldBegin("id1", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->id1.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("id2", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->id2.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(EquivEdge &a, EquivEdge &b) {
  using ::std::swap;
  swap(a.id1, b.id1);
  swap(a.id2, b.id2);
}

EquivEdge::EquivEdge(const EquivEdge& other4) {
  id1 = other4.id1;
  id2 = other4.id2;
}
EquivEdge& EquivEdge::operator=(const EquivEdge& other5) {
  id1 = other5.id1;
  id2 = other5.id2;
  return *this;
}
void EquivEdge::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "EquivEdge(";
  out << "id1=" << to_string(id1);
  out << ", " << "id2=" << to_string(id2);
  out << ")";
}


LinkedEdge::~LinkedEdge() throw() {
}


void LinkedEdge::__set_source(const PageID& val) {
  this->source = val;
}

void LinkedEdge::__set_target(const PageID& val) {
  this->target = val;
}
std::ostream& operator<<(std::ostream& out, const LinkedEdge& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t LinkedEdge::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_source = false;
  bool isset_target = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->source.read(iprot);
          isset_source = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->target.read(iprot);
          isset_target = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_source)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_target)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t LinkedEdge::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("LinkedEdge");

  xfer += oprot->writeFieldBegin("source", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->source.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("target", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->target.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(LinkedEdge &a, LinkedEdge &b) {
  using ::std::swap;
  swap(a.source, b.source);
  swap(a.target, b.target);
}

LinkedEdge::LinkedEdge(const LinkedEdge& other6) {
  source = other6.source;
  target = other6.target;
}
LinkedEdge& LinkedEdge::operator=(const LinkedEdge& other7) {
  source = other7.source;
  target = other7.target;
  return *this;
}
void LinkedEdge::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "LinkedEdge(";
  out << "source=" << to_string(source);
  out << ", " << "target=" << to_string(target);
  out << ")";
}


PageViewEdge::~PageViewEdge() throw() {
}


void PageViewEdge::__set_person(const PersonID& val) {
  this->person = val;
}

void PageViewEdge::__set_page(const PageID& val) {
  this->page = val;
}

void PageViewEdge::__set_nonce(const int64_t val) {
  this->nonce = val;
}
std::ostream& operator<<(std::ostream& out, const PageViewEdge& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PageViewEdge::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_person = false;
  bool isset_page = false;
  bool isset_nonce = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->person.read(iprot);
          isset_person = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->page.read(iprot);
          isset_page = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_I64) {
          xfer += iprot->readI64(this->nonce);
          isset_nonce = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_person)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_page)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_nonce)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PageViewEdge::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PageViewEdge");

  xfer += oprot->writeFieldBegin("person", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->person.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("page", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->page.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("nonce", ::apache::thrift::protocol::T_I64, 3);
  xfer += oprot->writeI64(this->nonce);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PageViewEdge &a, PageViewEdge &b) {
  using ::std::swap;
  swap(a.person, b.person);
  swap(a.page, b.page);
  swap(a.nonce, b.nonce);
}

PageViewEdge::PageViewEdge(const PageViewEdge& other8) {
  person = other8.person;
  page = other8.page;
  nonce = other8.nonce;
}
PageViewEdge& PageViewEdge::operator=(const PageViewEdge& other9) {
  person = other9.person;
  page = other9.page;
  nonce = other9.nonce;
  return *this;
}
void PageViewEdge::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageViewEdge(";
  out << "person=" << to_string(person);
  out << ", " << "page=" << to_string(page);
  out << ", " << "nonce=" << to_string(nonce);
  out << ")";
}


PagePropertyValue::~PagePropertyValue() throw() {
}


void PagePropertyValue::__set_page_views(const int32_t val) {
  this->page_views = val;
__isset.page_views = true;
}
std::ostream& operator<<(std::ostream& out, const PagePropertyValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PagePropertyValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->page_views);
          this->__isset.page_views = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PagePropertyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PagePropertyValue");

  if (this->__isset.page_views) {
    xfer += oprot->writeFieldBegin("page_views", ::apache::thrift::protocol::T_I32, 1);
    xfer += oprot->writeI32(this->page_views);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PagePropertyValue &a, PagePropertyValue &b) {
  using ::std::swap;
  swap(a.page_views, b.page_views);
  swap(a.__isset, b.__isset);
}

PagePropertyValue::PagePropertyValue(const PagePropertyValue& other10) {
  page_views = other10.page_views;
  __isset = other10.__isset;
}
PagePropertyValue& PagePropertyValue::operator=(const PagePropertyValue& other11) {
  page_views = other11.page_views;
  __isset = other11.__isset;
  return *this;
}
void PagePropertyValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PagePropertyValue(";
  out << "page_views="; (__isset.page_views ? (out << to_string(page_views)) : (out << "<null>"));
  out << ")";
}


PageProperty::~PageProperty() throw() {
}


void PageProperty::__set_id(const PageID& val) {
  this->id = val;
}

void PageProperty::__set_property(const PagePropertyValue& val) {
  this->property = val;
}
std::ostream& operator<<(std::ostream& out, const PageProperty& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PageProperty::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_property = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->property.read(iprot);
          isset_property = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_property)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PageProperty::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PageProperty");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->property.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PageProperty &a, PageProperty &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.property, b.property);
}

PageProperty::PageProperty(const PageProperty& other12) {
  id = other12.id;
  property = other12.property;
}
PageProperty& PageProperty::operator=(const PageProperty& other13) {
  id = other13.id;
  property = other13.property;
  return *this;
}
void PageProperty::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PageProperty(";
  out << "id=" << to_string(id);
  out << ", " << "property=" << to_string(property);
  out << ")";
}


Location::~Location() throw() {
}


void Location::__set_city(const std::string& val) {
  this->city = val;
__isset.city = true;
}

void Location::__set_state(const std::string& val) {
  this->state = val;
__isset.state = true;
}

void Location::__set_country(const std::string& val) {
  this->country = val;
__isset.country = true;
}
std::ostream& operator<<(std::ostream& out, const Location& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Location::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->city);
          this->__isset.city = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->state);
          this->__isset.state = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->country);
          this->__isset.country = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t Location::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Location");

  if (this->__isset.city) {
    xfer += oprot->writeFieldBegin("city", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->city);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.state) {
    xfer += oprot->writeFieldBegin("state", ::apache::thrift::protocol::T_STRING, 2);
    xfer += oprot->writeString(this->state);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.country) {
    xfer += oprot->writeFieldBegin("country", ::apache::thrift::protocol::T_STRING, 3);
    xfer += oprot->writeString(this->country);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Location &a, Location &b) {
  using ::std::swap;
  swap(a.city, b.city);
  swap(a.state, b.state);
  swap(a.country, b.country);
  swap(a.__isset, b.__isset);
}

Location::Location(const Location& other14) {
  city = other14.city;
  state = other14.state;
  country = other14.country;
  __isset = other14.__isset;
}
Location& Location::operator=(const Location& other15) {
  city = other15.city;
  state = other15.state;
  country = other15.country;
  __isset = other15.__isset;
  return *this;
}
void Location::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Location(";
  out << "city="; (__isset.city ? (out << to_string(city)) : (out << "<null>"));
  out << ", " << "state="; (__isset.state ? (out << to_string(state)) : (out << "<null>"));
  out << ", " << "country="; (__isset.country ? (out << to_string(country)) : (out << "<null>"));
  out << ")";
}


PersonPropertyValue::~PersonPropertyValue() throw() {
}


void PersonPropertyValue::__set_full_name(const std::string& val) {
  this->full_name = val;
__isset.full_name = true;
}

void PersonPropertyValue::__set_gender(const GenderType::type val) {
  this->gender = val;
__isset.gender = true;
}

void PersonPropertyValue::__set_location(const Location& val) {
  this->location = val;
__isset.location = true;
}

void PersonPropertyValue::__set_age(const int16_t val) {
  this->age = val;
__isset.age = true;
}
std::ostream& operator<<(std::ostream& out, const PersonPropertyValue& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PersonPropertyValue::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRING) {
          xfer += iprot->readString(this->full_name);
          this->__isset.full_name = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          int32_t ecast16;
          xfer += iprot->readI32(ecast16);
          this->gender = (GenderType::type)ecast16;
          this->__isset.gender = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->location.read(iprot);
          this->__isset.location = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_I16) {
          xfer += iprot->readI16(this->age);
          this->__isset.age = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t PersonPropertyValue::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PersonPropertyValue");

  if (this->__isset.full_name) {
    xfer += oprot->writeFieldBegin("full_name", ::apache::thrift::protocol::T_STRING, 1);
    xfer += oprot->writeString(this->full_name);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.gender) {
    xfer += oprot->writeFieldBegin("gender", ::apache::thrift::protocol::T_I32, 2);
    xfer += oprot->writeI32((int32_t)this->gender);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.location) {
    xfer += oprot->writeFieldBegin("location", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->location.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.age) {
    xfer += oprot->writeFieldBegin("age", ::apache::thrift::protocol::T_I16, 4);
    xfer += oprot->writeI16(this->age);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PersonPropertyValue &a, PersonPropertyValue &b) {
  using ::std::swap;
  swap(a.full_name, b.full_name);
  swap(a.gender, b.gender);
  swap(a.location, b.location);
  swap(a.age, b.age);
  swap(a.__isset, b.__isset);
}

PersonPropertyValue::PersonPropertyValue(const PersonPropertyValue& other17) {
  full_name = other17.full_name;
  gender = other17.gender;
  location = other17.location;
  age = other17.age;
  __isset = other17.__isset;
}
PersonPropertyValue& PersonPropertyValue::operator=(const PersonPropertyValue& other18) {
  full_name = other18.full_name;
  gender = other18.gender;
  location = other18.location;
  age = other18.age;
  __isset = other18.__isset;
  return *this;
}
void PersonPropertyValue::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PersonPropertyValue(";
  out << "full_name="; (__isset.full_name ? (out << to_string(full_name)) : (out << "<null>"));
  out << ", " << "gender="; (__isset.gender ? (out << to_string(gender)) : (out << "<null>"));
  out << ", " << "location="; (__isset.location ? (out << to_string(location)) : (out << "<null>"));
  out << ", " << "age="; (__isset.age ? (out << to_string(age)) : (out << "<null>"));
  out << ")";
}


PersonProperty::~PersonProperty() throw() {
}


void PersonProperty::__set_id(const PersonID& val) {
  this->id = val;
}

void PersonProperty::__set_property(const PersonPropertyValue& val) {
  this->property = val;
}
std::ostream& operator<<(std::ostream& out, const PersonProperty& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t PersonProperty::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_id = false;
  bool isset_property = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->id.read(iprot);
          isset_id = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->property.read(iprot);
          isset_property = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_id)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_property)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t PersonProperty::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("PersonProperty");

  xfer += oprot->writeFieldBegin("id", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->id.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("property", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->property.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(PersonProperty &a, PersonProperty &b) {
  using ::std::swap;
  swap(a.id, b.id);
  swap(a.property, b.property);
}

PersonProperty::PersonProperty(const PersonProperty& other19) {
  id = other19.id;
  property = other19.property;
}
PersonProperty& PersonProperty::operator=(const PersonProperty& other20) {
  id = other20.id;
  property = other20.property;
  return *this;
}
void PersonProperty::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "PersonProperty(";
  out << "id=" << to_string(id);
  out << ", " << "property=" << to_string(property);
  out << ")";
}


DataUnit::~DataUnit() throw() {
}


void DataUnit::__set_person_property(const PersonProperty& val) {
  this->person_property = val;
__isset.person_property = true;
}

void DataUnit::__set_page_property(const PageProperty& val) {
  this->page_property = val;
__isset.page_property = true;
}

void DataUnit::__set_equiv(const EquivEdge& val) {
  this->equiv = val;
__isset.equiv = true;
}

void DataUnit::__set_page_view(const PageViewEdge& val) {
  this->page_view = val;
__isset.page_view = true;
}

void DataUnit::__set_page_link(const LinkedEdge& val) {
  this->page_link = val;
__isset.page_link = true;
}
std::ostream& operator<<(std::ostream& out, const DataUnit& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t DataUnit::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;


  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->person_property.read(iprot);
          this->__isset.person_property = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->page_property.read(iprot);
          this->__isset.page_property = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 3:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->equiv.read(iprot);
          this->__isset.equiv = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 4:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->page_view.read(iprot);
          this->__isset.page_view = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 5:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->page_link.read(iprot);
          this->__isset.page_link = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  return xfer;
}

uint32_t DataUnit::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("DataUnit");

  if (this->__isset.person_property) {
    xfer += oprot->writeFieldBegin("person_property", ::apache::thrift::protocol::T_STRUCT, 1);
    xfer += this->person_property.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page_property) {
    xfer += oprot->writeFieldBegin("page_property", ::apache::thrift::protocol::T_STRUCT, 2);
    xfer += this->page_property.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.equiv) {
    xfer += oprot->writeFieldBegin("equiv", ::apache::thrift::protocol::T_STRUCT, 3);
    xfer += this->equiv.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page_view) {
    xfer += oprot->writeFieldBegin("page_view", ::apache::thrift::protocol::T_STRUCT, 4);
    xfer += this->page_view.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  if (this->__isset.page_link) {
    xfer += oprot->writeFieldBegin("page_link", ::apache::thrift::protocol::T_STRUCT, 5);
    xfer += this->page_link.write(oprot);
    xfer += oprot->writeFieldEnd();
  }
  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(DataUnit &a, DataUnit &b) {
  using ::std::swap;
  swap(a.person_property, b.person_property);
  swap(a.page_property, b.page_property);
  swap(a.equiv, b.equiv);
  swap(a.page_view, b.page_view);
  swap(a.page_link, b.page_link);
  swap(a.__isset, b.__isset);
}

DataUnit::DataUnit(const DataUnit& other21) {
  person_property = other21.person_property;
  page_property = other21.page_property;
  equiv = other21.equiv;
  page_view = other21.page_view;
  page_link = other21.page_link;
  __isset = other21.__isset;
}
DataUnit& DataUnit::operator=(const DataUnit& other22) {
  person_property = other22.person_property;
  page_property = other22.page_property;
  equiv = other22.equiv;
  page_view = other22.page_view;
  page_link = other22.page_link;
  __isset = other22.__isset;
  return *this;
}
void DataUnit::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "DataUnit(";
  out << "person_property="; (__isset.person_property ? (out << to_string(person_property)) : (out << "<null>"));
  out << ", " << "page_property="; (__isset.page_property ? (out << to_string(page_property)) : (out << "<null>"));
  out << ", " << "equiv="; (__isset.equiv ? (out << to_string(equiv)) : (out << "<null>"));
  out << ", " << "page_view="; (__isset.page_view ? (out << to_string(page_view)) : (out << "<null>"));
  out << ", " << "page_link="; (__isset.page_link ? (out << to_string(page_link)) : (out << "<null>"));
  out << ")";
}


Pedigree::~Pedigree() throw() {
}


void Pedigree::__set_true_as_of_secs(const int32_t val) {
  this->true_as_of_secs = val;
}
std::ostream& operator<<(std::ostream& out, const Pedigree& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Pedigree::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_true_as_of_secs = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_I32) {
          xfer += iprot->readI32(this->true_as_of_secs);
          isset_true_as_of_secs = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_true_as_of_secs)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Pedigree::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Pedigree");

  xfer += oprot->writeFieldBegin("true_as_of_secs", ::apache::thrift::protocol::T_I32, 1);
  xfer += oprot->writeI32(this->true_as_of_secs);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Pedigree &a, Pedigree &b) {
  using ::std::swap;
  swap(a.true_as_of_secs, b.true_as_of_secs);
}

Pedigree::Pedigree(const Pedigree& other23) {
  true_as_of_secs = other23.true_as_of_secs;
}
Pedigree& Pedigree::operator=(const Pedigree& other24) {
  true_as_of_secs = other24.true_as_of_secs;
  return *this;
}
void Pedigree::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Pedigree(";
  out << "true_as_of_secs=" << to_string(true_as_of_secs);
  out << ")";
}


Data::~Data() throw() {
}


void Data::__set_pedigree(const Pedigree& val) {
  this->pedigree = val;
}

void Data::__set_dataunit(const DataUnit& val) {
  this->dataunit = val;
}
std::ostream& operator<<(std::ostream& out, const Data& obj)
{
  obj.printTo(out);
  return out;
}


uint32_t Data::read(::apache::thrift::protocol::TProtocol* iprot) {

  ::apache::thrift::protocol::TInputRecursionTracker tracker(*iprot);
  uint32_t xfer = 0;
  std::string fname;
  ::apache::thrift::protocol::TType ftype;
  int16_t fid;

  xfer += iprot->readStructBegin(fname);

  using ::apache::thrift::protocol::TProtocolException;

  bool isset_pedigree = false;
  bool isset_dataunit = false;

  while (true)
  {
    xfer += iprot->readFieldBegin(fname, ftype, fid);
    if (ftype == ::apache::thrift::protocol::T_STOP) {
      break;
    }
    switch (fid)
    {
      case 1:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->pedigree.read(iprot);
          isset_pedigree = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      case 2:
        if (ftype == ::apache::thrift::protocol::T_STRUCT) {
          xfer += this->dataunit.read(iprot);
          isset_dataunit = true;
        } else {
          xfer += iprot->skip(ftype);
        }
        break;
      default:
        xfer += iprot->skip(ftype);
        break;
    }
    xfer += iprot->readFieldEnd();
  }

  xfer += iprot->readStructEnd();

  if (!isset_pedigree)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  if (!isset_dataunit)
    throw TProtocolException(TProtocolException::INVALID_DATA);
  return xfer;
}

uint32_t Data::write(::apache::thrift::protocol::TProtocol* oprot) const {
  uint32_t xfer = 0;
  ::apache::thrift::protocol::TOutputRecursionTracker tracker(*oprot);
  xfer += oprot->writeStructBegin("Data");

  xfer += oprot->writeFieldBegin("pedigree", ::apache::thrift::protocol::T_STRUCT, 1);
  xfer += this->pedigree.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldBegin("dataunit", ::apache::thrift::protocol::T_STRUCT, 2);
  xfer += this->dataunit.write(oprot);
  xfer += oprot->writeFieldEnd();

  xfer += oprot->writeFieldStop();
  xfer += oprot->writeStructEnd();
  return xfer;
}

void swap(Data &a, Data &b) {
  using ::std::swap;
  swap(a.pedigree, b.pedigree);
  swap(a.dataunit, b.dataunit);
}

Data::Data(const Data& other25) {
  pedigree = other25.pedigree;
  dataunit = other25.dataunit;
}
Data& Data::operator=(const Data& other26) {
  pedigree = other26.pedigree;
  dataunit = other26.dataunit;
  return *this;
}
void Data::printTo(std::ostream& out) const {
  using ::apache::thrift::to_string;
  out << "Data(";
  out << "pedigree=" << to_string(pedigree);
  out << ", " << "dataunit=" << to_string(dataunit);
  out << ")";
}


